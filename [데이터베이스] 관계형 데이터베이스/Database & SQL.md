# Goal
> 서버와 클라이언트 사이에서 주고 받는 데이터를 database에 저장하여 영속성있게 저장한다.

백엔드 개발에서 매우 중요한 데이터베이스를 학습한다. 이번 유닛은 다음의 세 가지의 큰 흐름을 따라 진행한다.

+ SQL 문법
+ 스키마 디자인 (Schema design)
+ Node.js에서 데이터베이스를 사용하는 방법

이전에는 데이터를 서버 컴퓨터의 in-memory 방식으로 저장하고, 클라이언트의 HTTP 요청에 따라 서버에서 알맞은 데이터를 응답했다. in-memory 방식은 서버 프로그램이 실행중일 때, 변수에 값을 할당하여 저장하는 것을 의미다. 이 방식에서는 서버 프로그램을 재실행하거나 종료하면, 이전에 변수에 저장한 값이 휘발된다. in-memory 방식이 아니라면, Node.js의 fs 모듈 중 readFile이나 writeFile method 등을 이용해 데이터를 파일에 저장할 수도 있다. <br>

이번 유닛에서는 새로운 tier를 하나 더 추가하여, 서버에서 데이터를 저장하는 방법이 in-memory에서 파일로, 파일에서 데이터베이스로 바뀌는 과정을 학습한다. <br>


## 데이터베이스가 필요한 이유
+ In-memory
  - 변수에 데이터를 저장하는 방법이다
  - 끄면 데이터가 없어짐
+ File I/O
  - 메모장이나 어떤 형태로든 데이터를 파일에 저장하는 방식
  - 원하는 데이터만 가져올 수 없고 항상 모든 데이터를 가져온 뒤 서버에서 필터링 필요
  - ex) 메모장에 1000줄의 내용이 있고 그 중에 한 줄만 필요하지만 메모장의 1000줄을 모두 읽어야 한다
+ Database
  - 필터링 외에도 File I/O로 구현이 힘든 관리를 위한 여러 기능들을 가지고 있는 데이터에 특화된 서버
  - SQL을 통해 필요한 정보만 가져올 수 있다 <br>


### 흐름
client에서 "여자 직원들 목록 보여줘"라고 요청을 하면 server에서 
```js
SELECT * FROM employee WHERE gender = 'F';
``` 
라고 요청한다. 그럼 Database에서 필터링을 한 후 결과값을 서버에 전달해준다. 서버는 이미 필터된 데이터를 받아왔기 때문에 가공할 필요없이 client에게 보여준다. <br>


## SQL
+ SQL 이란?
  - Structured Query Language -> 구조화된 Query 언어
+ Query 란?
  - "질의문"
  - 가장 친숙한 예시로는 검색창에 적는 검색어도 Query의 일종
  - 저장되어있는 정보를 필터하기 위한 질문 
  - 혹은 쿼리를 보내 원하는 데이터를 삽입할 수도 있다
+ 그래서 다시 SQL 이란?
  - 데이터베이스 용 프로그래밍 언어
  - 데이터베이스에 query를 보내 원하는 데이터만을 뽑아올 수 있다 


## 트랜잭션
> 트랜잭션이란 여러 개의 작업을 하나로 묶은 실행 유닛. 각 트랜잭션은 하나의 특정 작업으로 시작을 해 묶여 있는 모든 작업들을 다 완료해야 정상적으로 종료한. 만약 하나의 트랜잭션에 속해있는 여러 작업 중에서 단 하나의 작업이라도 실패하면, 이 트랜잭션에 속한 모든 작업을 실패한 것으로 판단한다. 성공 또는 실패 라는 두 개의 결과만 존재하는 트랜잭션은, 미완료된 작업없이 모든 작업을 성공해야 한다.

계좌이체를 하려는데 A 계좌에서는 출금이 이뤄지고, B 계좌에 입금되지 않았다고 가정해보자. 어디서 문제가 발생했는지 파악할 수 없다면, A 계좌에서 출금된 돈은 세상에서 사라지는 돈이 된다. 이런 상황을 방지하기 위해 트랜잭션은 ACID라는 특성을 가지고 있다. <br>

### ACID
데이터 베이스에서 트랜잭션이 발생할 때, 그 안정성을 보장할 수 있는 성질. <br>
전자 상거래를 비롯한 모든 금융 서비스를 위한 소프트웨어 개발 에서는 반드시 데이터베이스의 ACID 성질을 준수해야 한다. 그래서 이런 경우에는 일반적으로 NO SQL이 아닌, SQL을 이용한 관계형 데이터베이스를 사용한다.<br>

#### 1. Atomicity(원자성)
하나의 트랜잭션 내에서 모든 연산(작업)이 성공하거나 모두 실패해야 한다. <br>

만약 은행에서 A 계좌에서 출금하는 일에 성공했지만, B 계좌에 입금하는 작업에 실패한다면 계좌 A에서 출금하는 작업을 포함하여 모든 작업이 실패로 돌아가야 한다는 것이 Atomicity(원자성)이다. 롤백이라고도 한다.

#### 2. Consistency(일관성)
하나의 트랜잭션 전후에 데이터베이스의 일관된 상태가 유지되어야 한다. <br>
트랜잭션이 일어난 이후의 데이터베이스는 데이터베이스의 제약이나 규칙을 만족해야 한다는 뜻이다. 예를 들어, 은행에서 예금을 개설할 때 예금을 위한 고객의 이름을 받아야 한다. 그런데 여기서 이름을 뺀 예금을 만들어 달라고 하면 데이터 베이스의 일관성을 깨게 되는 것이다.


#### 3. Isolation(격리성, 고립성)
각각의 트랜잭션은 독립적. 서로의 연산을 확인받거나 영향을 줄 수 없다. <br>
내가 A에게 송급하는 것과 B에게 송금하는 것은 각각 독립적이다.


#### 4. Durability(지속성)
하나의 성공된 트랜잭션에 대한 로그가 기록되고 영구적으로 남는다. 만약 런타임 오류나 시스템 오류가 발생하더라도, 해당 기록은 영구적이어야 한다.

+ A 계좌로 이체 성공 -> 은행 서버 에러 -> A 계좌로 이체 기록은 영구적으로 유지
+ B 계좌로 이체 실패 -> 이제 요청 이전 상태로 회귀(롤백)


## SQL 접속하기

### 1. MySQL 설치
패키지 매니저 Homebrew를 이용해 MySQL을 설치한다.

#### Homebrew를 이용한 설치
```js
brew install mysql
brew info mysql
```

### 2. MySQL 서비스 시작
MySQL을 설치했다면, MySQL 프로그램을 실행해야 한다.
그렇지 않으면 MySQL을 사용할 수 없다.

macOS
```js
brew services start mysql
```

### 3. MySQL 접속
다음의 명령어로 MySQL에 접속할 수 있다.
```js
mysql -u root
```

MySQL을 처음 설치하면, root의 암호는 비어 있다. Enter 키를 누르자.
비밀번호를 설정하고 나면, 다음의 명령어로 MySQL에 접속해야 한다.

```js
// -u(계정 접근), -p(비밀번호)
mysql -u root -p
```