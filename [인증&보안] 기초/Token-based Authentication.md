## 토큰기반 인증 (Token-based Authentication)
--- 

### 토큰기반 인증은 왜, 그리고 언제 쓸까?
세션 기반 인증은 서버(혹은 DB)에 유저 정보를 담는 인증 방식이었다. 서버에서는 유저가 민감하거나 제한된 정보를 요청할 때마다 "지금 요청을 보낸 유저에게 우리가 정보를 줘도 괜찮은가?" 를 확인하기 위해 가지고 있는 세션 값과 일치하는지 확인한다. 그러나 매 요청마다 데이터베이스를 살펴보는 것이 불편하고, 세션은 서버당 하나만 갖기 때문에 다른 서버에 요청을 보낸다면 또 세션 값을 만들어야하는 복잡성이 있다. 따라서 분산시스템(서버가 여러개일 때)일 때 관리가 어렵다. 이럴 때 사용할 수 있는 토큰기반 인증 중 대표적인 JWT (JSON Web Token) 에 대해서 알아보자.

### 클라이언트에서 인증 정보 보관하기
+ 오락실 게임에 사용하는 토큰
+ 행사에 입장하기 위해서 주최 측에서 나누어 준 토큰
+ 놀이공원에 입장료를 내면 주는 토큰
위 토큰들은 공통적으로 `나는 돈을 지불했고, 이 시설을 사용할 수 있어!` 라는 메시지를 담고 있다. 이 토큰이 황금색으로 빛난다면 더 프리미엄 기능을 사용하게끔 만들었을 수도 있겠다.

클라이언트에서 인증 정보를 보관하는 방법으로 토큰기반 인증이 고안되었다. 클라이언트가 토큰을 가지고 있다면 보통의 다른(돈을 내지 않은) 유저들과는 다르게 서버에서 제공하는 다양한, 더 프리미엄한 기능을 요청할 수 있을 것이다. 그런데 토큰을 클라이언트에 저장해도 정말 괜찮은 걸까? 클라이언트는 XSS, CSRF공격에 노출이 될 위험이 있으니 민감한 정보를 담고 있어서는 안된다는 것을 기억하실 것이다. 그렇다면 "민감한 정보는 클라이언트에 담으면 안 된다면서, 인증에 사용되는걸 클라이언트에 담는다고?" 라는 의문이 들 것이다.

> 토큰은 유저 정보를 암호화한 상태로 담을 수 있고, 암호화했기 때문에 클라이언트에 담을 수 있다.

### JWT의 종류
1. Access Token
2. Refresh Token

Access token은 보호된 정보들(유저의 이메일, 연락처, 사진 등)에 접근할 수 있는 권한부여에 사용한다. 클라이언트가 처음 인증을 받게 될 때(로그인 시), access, refresh token 두가지를 다 받지만, 실제로 권한을 얻는 데 사용하는 토큰은 access token 이다.

> 그럼 access token만 있으면 되는 것 아닌가요?

권한을 부여 받는데엔 access token만 가지고 있으면 된다. 하지만 access token을 만약 악의적인 유저가 얻어냈다면 어떻게 될까? 이 악의적인 유저는 자신이 진짜 유저인것 마냥 서버에 여러가지 요청을 보낼 수 있다(만약 돈과 관련된 문제라면 큰일이 날 수 있겠다). 그렇기 때문에 access token에는 비교적 짧은 유효기간을 주어 탈취 되더라도 오랫동안 사용할 수 없도록 하는것이 좋다.

Access token의 유효기간이 만료된다면 refresh token을 사용하여 새로운 access token을 발급받는다. 이때, 유저는 다시 로그인할 필요가 없다.

> refresh token도 탈취 당한다면요?

유효기간이 긴 refresh token마저 악의적인 유저가 얻어낸다면 큰 문제가 될 것이다. 상당히 오랜 기간동안 access token이 만료되면 다시 발급 받으며 유저에게 피해를 입힐 수 있기 때문이다. 그렇기 때문에 유저의 편의보다 정보를 지키는 것이 더 중요한 웹사이트들은 refresh token을 사용하지 않는 곳이 많다. 세상에 완벽한 보안은 없기 때문에 (있다면 쿠키, 세션, JWT, OAuth 등 다양한 방법들을 공부하지 않아도 될 것이다.) 각 방법들의 장단점을 참고하며 필요에 맞게 사용하는 것이 좋다.

### JWT 구조
![구조]('../img/JWT구조.png')

JWT는 위 그림과 같이 . 으로 나누어진 3부분이 존재합니다.

1. Header

Header는 이것이 어떤 종류의 토큰인지(지금의 경우엔 JWT), 어떤 알고리즘으로 sign(암호화) 할지가 적혀있다. JSON Web Token 이라는 이름에 걸맞게 JSON형태로 이런 형태를 보실 수 있다.
```js
{
  "alg": "HS256",
  "typ": "JWT"
}
```
이 JSON 객체를 base64 방식으로 인코딩하면 JWT의 첫 번째 부분이 완성된다.

2. Payload

Payload에는 정보가 담겨 있습니다. 어떤 정보에 접근 가능한지에 대한 권한을 담을 수도 있고, 사용자의 유저 이름 등 필요한 데이터는 이곳에 담아 암호화 시킨다. 물론 암호화(헤더에서 정의한)가 될 정보지만, 민감한 정보는 되도록 담지 않는 것이 좋다.
```js
{
  "sub": "someInformation",
  "name": "phillip",
  "iat": 151623391
}
```
첫번째 부분과 마찬가지로, 위 JSON 객체를 base64로 인코딩하면 JWT의 두 번째 블록이 완성됩다.

3. Signature

base64로 인코딩된 첫번째, 그리고 두번째 부분이 완성 되었다면, 원하는 비밀 키(암호화에 추가할 salt)를 사용하여 암호화한다. base64 인코딩을 한 값은 누구나 쉽게 디코딩할 수 있지만, 서버에서 사용하고 있는 비밀키를 보유한게 아니라면 해독해내는데 엄청난 시간과 노력이 들어갈 것이다.

예를 들어, 만약 HMAC SHA256 알고리즘(암호화 방법중 하나)을 사용한다면 signature는 아래와 같은 방식으로 생성된다.
```js
HMACSHA256(base64UrlEncode(header) + '.' + base64UrlEncode(payload), secret);
```

### JWT 사용 예시
JWT는 권한 부여에 굉장히 유용하다. 새로 다운받은 A라는 앱이 Gmail과 연동되어 이메일을 읽어와야 한다고 생각해 보자. 유저는

1. Gmail 인증서버에 로그인정보(아이디, 비밀번호)를 제공한다
2. 성공적으로 인증시 JWT 를 발급받는다
3. A앱은 JWT를 사용해 해당 유저의 Gmail 이메일을 읽거나 사용할 수 있다


### 토큰기반 인증 절차
1. 클라이언트가 서버에 아이디/비밀번호를 담아 로그인 요청을 보낸다.
2. 아이디/비밀번호가 일치하는지 확인하고, 클라이언트에게 보낼 암호화된 토큰을 생성한다.
    - access/refresh 토큰을 모두 생성한다.
    - 토큰에 담길 정보(payload)는 유저를 식별할 정보, 권한이 부여된 카테고리(사진, 연락처, 기타등등)이 될 수 있다.
    - 두 종류의 토큰이 같은 정보를 담을 필요는 없다 (이 스프린트에서는 같은 정보를 담아줍시다).
3. 토큰을 클라이언트에게 보내주면, 클라이언트는 토큰을 저장한다.
    - 저장하는 위치는 local storage, cookie, react의 state 등 다양하다.
4. 클라이언트가 HTTP 헤더(authorization 헤더)에 토큰을 담아 보낸다.
    - bearer authentication을 이용한다. 참고 링크1(요약), 링크2(상세)
5. 서버는 토큰을 해독하여 `"아 우리가 발급해준 토큰이 맞네!"` 라는 판단이 될 경우, 클라이언트의 요청을 처리한 후 응답을 보내준다.


![구조]('../img/JWT인증절차.jpeg')

### 토큰기반 인증의 장점
1. Statelessness & Scalability (무상태성 & 확장성)
    - 서버는 클라이언트에 대한 정보를 저장할 필요 없다 (토큰 해독이 되는지만 판단한다)
    - 클라이언트는 새로운 요청을 보낼때마다 토큰을 헤더에 포함시키면 된다
    - 서버를 여러개 가지고 있는 서비스라면 더더욱 빛을 발휘한다 (같은 토큰으로 여러 서버에서 인증 가능)
      - 세션은 서버당 하나만 갖기 때문에 분산시스템(서버가 여러 개일때)일 때 관리가 어렵다

2. 안전하다
    - 암호화 한 토큰을 사용하고, 암호화 키를 노출 할 필요가 없기 때문에 안전하다
3. 어디서나 생성 가능하다
    - 토큰을 확인하는 서버가 토큰을 만들어야 하는 법이 없다
    - 토큰 생성용 서버를 만들거나, 다른 회사에서 토큰관련 작업을 맡기는 것 등 다양한 활용이 가능하다
4. 권한 부여에 용이하다
    - 토큰의 payload(내용물) 안에 어떤 정보에 접근 가능한지 정할 수 있다
     - ex) 서비스의 사진과 연락처 사용권한만 부여
