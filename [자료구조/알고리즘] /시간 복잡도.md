알고리즘 문제를 풀 때 효율적인 방법을 고민한다는 것은 시간 복잡도를 고민한다는 것과 같은 말이다. 시간 복잡도와 Big-O(빅-오) 표기법에 대해서 배워 보도록 하겠다.
------

# 시간 복잡도
문제를 해결하기 위해 알고리즘 로직을 코드로 구현할 때 시간 복잡도를 고려한다는 건 무슨 의미일까? 한 문장으로 정리하자면 다음과 같다.

> 입력값의 변화에 따라 연산을 실행할 때, 연산 횟수에 비해 시간이 얼마만큼 걸리는가?

효율적인 알고리즘을 구현한다는 것은, **입력값이 커짐에 따라 증가하는 시간의 비율을 최소화한 알고리즘** 을 구성했다는 말이다. 그리고 이 시간 복잡도는 주로 빅-오 표기법을 사용해 나타낸다.


# Big-O 표기법
시간 복잡도를 표기하는 방법은 다음과 같다.
+ Big-O(빅-오)
+ Big-Ω(빅-오메가)
+ Big-θ(빅-세타)

시간 복잡도를 각각 최악, 최선, 중간(평균)의 경우에 대하여 나타내는 방법이다. 그 중에서 Big-O 표기법이 가장 자주 사용된다. 최악의 경우가 발생하지 않기를 바라며 시간을 계산하는 것보다는 최악의 경우도 고려하여 대비하는 것이 바람직하기 때문이다. 

## Big-O 표기법의 종류

### O(1)
입력값의 크기와 관계없이, 즉시 출력값을 얻어낼 수 있다. </br>
값을 한번에 찾을 수 있는 것 ex) arr[i]

```js
function O_1_algorithm(arr, index) {
	return arr[index];
}

let arr = [1, 2, 3, 4, 5];
let index = 1;
let result = O_1_algorithm(arr, index);
console.log(result); // 2
```


### O(n)
입력값이 증가함에 따라 시간 또한 같은 비율로 증가한다. ex) 반복문
```js
function O_n_algorithm(n) {
	for (let i = 0; i < n; i++) {
	// do something for 1 second
	}
}
```


### O(log n)
필요하지 않은 부분을 버리며 반절씩 나눠 값을 확인한다. Big-O표기법중 O(1) 다음으로 빠른 시간 복잡도를 가진다. Binary Search Tree, up & down 게임이 그 예다.


### O(n2) n의 2승
입력값이 증가함에 따라 시간이 n의 제곱수의 비율로 증가한다. </br>
ex) 이중 반복문

```js
function O_quadratic_algorithm(n) {
	for (let i = 0; i < n; i++) {
		for (let j = 0; j < n; j++) {
		// do something for 1 second
		}
	}
}

```


### O(2n) 2의 n승
Big-O 표기법 중 가장 느린 시간 복잡도를 가진다.
```js
function fibonacci(n) {
	if (n <= 1) {
		return 1;
	}
	return fibonacci(n - 1) + fibonacci(n - 2);
}
```
재귀로 구현하는 피보나치 수열은 O(2n)의 시간 복잡도를 가진 대표적인 알고리즘이다.



### 데이터 크기에 따른 시간 복잡도
일반적으로 코딩 테스트에서는 정확한 값을 제한된 시간 내에 반환하는 프로그램을 작성해야 한다. 따라서, 입력 데이터가 클 때는 O(n) 혹은 O(log n)의 시간 복잡도를 만족할 수 있도록 예측해서 문제를 풀어야 한다. 그리고 주어진 데이터가 작을 때는 시간 복잡도가 크더라도 문제를 풀어내는 것에 집중하는 게 좋다.

| 데이터 크기 제한 | 예상되는시간 복잡도 | 
|---|:---:|
|n ≤ 1,000,000 | O(n) or O (logn)
|n ≤ 10,000	|   O(n2)
|n ≤ 500	|   O(n3)